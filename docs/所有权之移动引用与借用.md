### 移动、引用与借用

在对比这几个概念前，我们都知道内存中有 堆(heap)和栈(stack)，在 Rust 中我们声明的基本数据类型 `字符型` `整形` `浮点型` `布尔型` 都是在 **栈** 中，而其他 `复合类型` 都在 **堆** 中，因此使用复杂类型时都是通过指针(Pointer) 进行地址查找并操作

所有权规则：
> Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。  
值有且只有一个所有者。  
当所有者（变量）离开作用域，这个值将被丢弃。

- 所谓移动(针对复合类型的概念，基本类型不需要移动)，首先这个是 Rust 在设计底层语言时，为了保证数据的高效和安全性考虑，给出的一个作用域策略  
  - **堆数据变量** 的所有权总是遵循相同的模式：当一个变量赋值给另一个变量时，移动（Move） 它
  - 当持有堆（Heap）中数据值变量，离开作用域时，其值将通过 **drop** 被清理掉，除非数据被移动为另一个变量所有

  这样就能确保，当前作用域只有一个变量用拥有该值的所有权，那么移动(Move) 就是数据所有权的一次变更，_个人觉得 move 翻译成 ”转移“ 可能更加准确_

- 引用就是地址的传递，与其他语言概念一致，但只是引用，没有所有权，_只读_
- 借用(Borrowing)是我们创建引用的这个动作，并且借用会获得所有权
  > We call the action of creating a reference _borrowing_.  
  > 在说的直接点就是使用了 `&mut` 符号， __可变引用就是借用__

  ```rust
  let mut str1 = String::from("hello");
  let str2 = &str1; // &str1是一个不可变引用，它赋值给了 str2，因此 str2 指向了 str1
  let str3 = &mut str1; // str3 是对 str1 的可变引用，因此 str3 是对 str1 的借用

  // 但，如果我们在可变引用(借用)之后(即 str3后)，使用了引用(str2)，那么 Rust 是不允许的，因为 str3 是可以修改值的，那么 str2 的值也就存在被修改的风险，造成错误，这也就是 Rust 所有权及内存回收的机制决定的

  // println!("str2 = {}", str2); // 错误
  ```

  总结：**在同一个作用域内，要么只能有一个可变引用，要么只能有多个不可变引用，不能同时存在可变和不可变引用**