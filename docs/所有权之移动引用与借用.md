### 移动、引用与借用

在对比这几个概念前，我们都知道内存中有 堆(heap)和栈(stack)，在 Rust 中我们声明的基本数据类型 `字符型` `整形` `浮点型` `布尔型` 都是在 **栈** 中，而其他 `复合类型` 都在 **堆** 中，因此使用复杂类型时都是通过指针(Pointer) 进行地址查找并操作

所有权规则：
> Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。  
值有且只有一个所有者。  
当所有者（变量）离开作用域，这个值将被丢弃。

- 所谓移动(针对复合类型的概念，基本类型不需要移动)，首先这个是 Rust 在设计底层语言时，为了保证数据的高效和安全性考虑，给出的一个作用域策略  
  - **堆数据变量** 的所有权总是遵循相同的模式：当一个变量赋值给另一个变量时，移动（Move） 它
  - 当持有堆（Heap）中数据值变量，离开作用域时，其值将通过 **drop** 被清理掉，除非数据被移动为另一个变量所有

  这样就能确保，当前作用域只有一个变量用拥有该值的所有权，那么移动(Move) 就是数据所有权的一次变更

- 引用就是地址的传递，与其他语言概念一致
- 借用(Borrowing)是我们创建引用的这个动作
  > We call the action of creating a reference _borrowing_.  
  > 在说的直接点就是使用了 `&` 符号， __创建地址引用的动作就是借用__

  ```rust
  let str1 = String::from("hello");
  let str2 = &str1; // &str1是一个不可变引用，它赋值给了 str2，因此 str2 借用了 str1
  ```